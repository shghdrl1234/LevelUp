package 정렬알고리즘;

import java.util.Arrays;

public class SelectionSort {
	/*
	 * 선택 정렬은 말 그대로 현재 위치에 들어갈 데이터를 찾아 선택하는 알고리즘이다.
	 * 데이터를 비교하면서 찾기 때문에 비교 정렬이며, 정렬의 대상이 되는 데이터 외에 추가적인
	 * 공간을 필요로 하지 않기 때문에 제자리 정렬이기도 하다.
	 * 
	 * 데이터를 서로 교환하는 과정에서 임시 변수를 필요로 하나, 이는 충분히 무시할 만큼 적은 양이다.
	 * 
	 * 정렬의 전체적인 과정은 이렇다.
	 * 1. 주어진 리스트에서 최솟값을 찾는다.
	 * 2. 최솟값을 맨 앞 자리의 값과 교환한다.
	 * 3. 맨 앞자리를 제외한 나머지 값들 중 최솟값을 찾아 위와 같은 방법으로 반복한다.
	 * 
	 * 
	 * 장점으로는 추가적인 메모리 소비가 작다.
	 * 
	 * 하지만 시간 복잡도가 O(N^2)이고, 안정 정렬이 아니다.
	 * 
	 * 안정하지 않다는 것은, 동등한 값이 있다해도, 그 동등한 값들의 위치가
	 * 비교 정렬 되면서,주변 데이터에 따라 임의로 바뀐다는 뜻이다.
	 * 
	 * 쉽게 말하면, B1, B2, C, A 의 원소가 있으며, B1과 B2는 같은 값으로 가정한다.
	 * 순회를 하다보면 
	 * A, B2, C, B1
	 * A, B2, C, B1
	 * A, B2, B1, C 처럼 
	 * 초기의 B1 B2 였던 순서가 B2 B1으로 바뀐 것을 볼 수 있다.
	 * 
	 * 이게 왜 중요하냐면, 정렬 규칙이 다수이거나 특정 순서를 유지해야하는 경우 문제가 될 수 있기 때문이다.
	 * 
	 * [(가영, 60), (가희, 60), (찬호, 70), (동우, 45)] 이렇게 리스트가 존재한다고 생각해보자.
	 * 성적순이되, 성적이 같다면 이름순으로 정렬해야한다.
	 * 
	 * 이름을 먼저 정렬한다.
	 * [(가영, 60), (가희, 60), (동우, 45), (찬호, 70)]
	 *  
	 * 그 다음 성적 순으로 정렬 할 것이다. 만약 선택 정렬을 하게되면.
	 * round 1: [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]
	 * round 2: [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]
	 * round 3: [(동우, 45), (가희, 60), (가영, 60), (찬호, 70)]
	 * 
	 * 이렇게 결과가 나와, 이름순으로 정렬하였을 때, 
	 * 가영이가 가희보다 앞에 있었지만,
	 * 
	 * 성적순으로 정렬하면 가희가 가영이보다 앞에 있게 된다.
	 * 
	 * 
	 * 
	 * 
	 */
	public static void main(String[] args) {
		int[] a = {2,13,4,5,45,10,30,22,5,6};
		
		selection_sort(a, a.length);
		System.out.println("정렬 완료" + Arrays.toString(a));

	}

	private static void selection_sort(int[] a, int size) {
		
		for(int i = 0; i < size -1; i++) {
			int min_index = i;
			
			for(int j = i+1; j < size; j++) {
				if(a[j] < a[min_index]) {
					min_index = j;
				}
				System.out.println("i : " + i + ", j : " + j +" // "+Arrays.toString(a));
			}
			
			// i번쨰 값과 찾은 최솟값을 서로 교환
			swap(a, min_index, i);
		}
	}
	
	private static void swap(int[] a, int i, int j) {
		int temp = a[i];
		a[i] = a[j];
		a[j] = temp;
	}
}
