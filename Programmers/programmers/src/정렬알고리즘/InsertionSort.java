package 정렬알고리즘;

public class InsertionSort {
	/*
	 * 삽입 정렬은 현재 비교하고자 하는 target과 그 이전의 원소들과 비교하며 자리를 교환하는 정렬 방법이다.
	 * 
	 * 삽입 정렬은 데이터를 비교하면서 찾기 때문에 비교 정렬이며, 정렬의 대상이 되는 데이터 외에 추가적인 공간을
	 * 필요로 하지 않기 때문에 제자리 정렬이기도 하다.
	 * 
	 * 정확히는 데이터를 서로 교환하는 과정에서 임시 변수를 필요로하나, 이는 충분히 무시할 만큼 적은 양이기 떄문에
	 * 제자리 정렬로 보는 것이다. 이는 선택 정렬과도 같은 부분이다.
	 * 
	 * 그리고 비교 정렬임과 동시에 안정 정렬이다.
	 * 
	 * 정렬 방법은 앞에서부터 해당 원소가 위치할 곳을 탐색하고 해당 위치에 삽입하는 것이다.
	 * 
	 * 삽입 정렬의 전체적인 과정은
	 * 1. 현재 타켓이 되는 숫자와 이전 위지에 있는 원소들을 비교한다.
	 * 2. 타겟이 되는 숫자가 이전 위치에 있던 원소보다 작다면 위치를 서로 교환한다.
	 * 3. 그 다음 타겟을 찾아 위와 같은 방법으로 반복한다.
	 * 
	 * 구현 자체는 어렵지 않으며, 결과적으로 타겟 이전 원소가 타겟 숫자보다 크기 직전까지 모든 수를
	 * 뒤로 한 칸씩 밀어내는 것이다.
	 * 
	 * 삽입 정렬의 장점으로는 
	 * 1. 추가적인 메모리 소비가 작다.
	 * 2. 거의 정렬된 경우 매우 효율적이다. 즉, 최선의 경우 O(N)의 시간복잡도를 갖는다.
	 * 3. 안정정렬이 가능하다.
	 * 
	 * 단점으로는 
	 * 1. 역순에 가까울 수록 매우 비효율적이다. 즉, 최악의 경우 O(N)의 시간복잡도를 갖는다.
	 * 2. 데이터의 상태에 따라서 성능 편차가 매우 크다.
	 * 
	 * 시간 복잡도에 대해 잠깐 언급하자면, (오름차순 정렬 기준)타겟 숫자가 이전 숫자보다 크기 전까지
	 * 반복하기 때문에 이미 정렬되어 있는 경우 항상 타겟 숫자가 이전 숫자보다 크다.
	 * 즉, 값을 N번만 비교하기 때문에 최선의 경우 O(N)의 시간 복잡도를 갖게 되는 것이다.
	 * 
	 * 반대로 최악의 경우는 타겟 숫자가 이전 숫자보다 항상 작기 때문에 결국 N번째 숫자에 대하여 N-1 번을
	 * 비교해야한다. 그렇기 때문에 최악의 경우는 O(N^2)의 시간복잡도를 보인다.
	 * 
	 * 평균 시간복잡도는 O(N^2)의 시간복잡도를 갖는다.
	 * 
	 * 버블정렬, 선택정렬과 이론상 같은 시간복잡도를 갖음에도 평균 비교횟수에 대한 기댓값이
	 * 상대적으로 적기 때문에 평균 시간복잡도가 O(N^2)인 정렬 알고리즘 중에서는 빠른 편에 속하는 알고리즘이다.
	 * 
	 * 삽입 정렬의 경우 거의 정렬된 배열에서 좋은 성능을 보이기 떄문에 실제로 병합정렬괴 삽입 정렬을 혼합한 Tim정렬이 있다.
	 * 이후 팀 정렬을 정리하겠다.
	 * 
	 * 팀 정렬 뿐만아니라, 삽입 정렬을 활용한 정렬은 쉘 정렬도 있는데, 이 또한 자주 쓰이니 빠른 시일내에 정리 하도록 하겠다.
	 */
	
	public static void insertion_sort(int[] a) {
		insertion_sort(a, a.length);
	}
	
	private static void insertion_sort(int[] a, int size) {
		
		
		for(int i = 1; i < size; i++) {
			// 타겟 넘버
			int target = a[i];
			
			int j = i - 1;
			
			// 타겟이 이전 원소보다 크기 전 까지 반복
			while(j >= 0 && target < a[j]) {
				a[j + 1] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j--;
			}
			
			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + 1 에 위치하게 된다.
			 */
			a[j + 1] = target;	
		}
		
	}
}
