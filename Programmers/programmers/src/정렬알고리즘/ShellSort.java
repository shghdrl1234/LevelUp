package 정렬알고리즘;

public class ShellSort {
/*
 * 셀 정렬은 기본적으로 삽입 정렬을 기반으로 한다.
 * 삽입 정렬은 타겟과 그 이전의 원소들과 비교하여 자리를 교환하는 정렬 방법이다.
 * 
 * 기본적으로 삽입정렬은 이전의 원소들을 "모두" 탐색하면서 위치를 교환해야하는 단점이 존재한다.
 * 그렇다보니 정렬하고자하는 순서와 반대, 즉 역순에 가까울수록 최악의 시간복잡도를 보이게된다.
 * 
 * 반대로 삽입정렬의 장점은 정렬된 상태에 가까울 수록 시간복잡도가 O(N)에 가까워 진다.
 * 
 * 즉, 장점을 부각시키고, 단점을 최소화하기위해 고안된 방식이 바로 쉘정렬이다.
 * 
 * 그렇다면 어떻게 단점을 줄일 수 있을까?
 * 삽입 정렬의 단점은 오름차순 기준으로 타겟 원소가 이전의 원소보다 작을 경우 이전 원소들 모두 
 * 교환한다는 것이다.
 * 
 * 즉, 이전의 원소를 모두 비교, 교환하는 것이 아니라 일정 간격 주기로 띄엄띄엄 검사하면서 교환하여
 * 타겟 원소의 위치를 대략적으로 잡아주는 것이다.
 * 
 * 그리고 위와 같은 과정을 "간격을 줄여가면서" 정렬해 나가다보면 정렬기준에 가까워지지 않겠는가?
 * 그러면 삽입 정렬의 장점인 거의 정렬 된 상태일 경우 정렬 속도가 빠르다는 이점 또한 가져갈 수 있다.
 * 
 * 쉽게말해 정렬하고자 하는 원소가 10개가 있을 때 간격을 3으로 설정하여 간격이 3인 원소들끼리 삽입정렬을 하고
 * 그 다음 간격을 2로 조정하여 2칸씩 떨어진 원소들끼리 삽입정렬을 하고, 최종적으로 간격이 1인 즉, 우리가 알고있는
 * 기본적인 삽입정렬을 하는 것이다.
 * 이러한 과정을 거치는 것이 바로 셀 정렬이라는 것이다.
 * 
 * 셀 정렬은 삽입 정렬을 기반으로 하니 일단 셀 정렬의 특징만 짚고 넘어가보자.
 * 
 * 셀 정렬은 데이터를 비교하면서 찾기 때문에 비교 정렬이며 정렬의 대상이 되는 데이터 외에 추가적인
 * 공간을 필요로 하지 않기 때문에 제자리 정렬이기도 하다. 정확히는 데이터를 서로 교환하는 과정에서 임시 변수를
 * 필요로 하나, 이는 충분히 무시할 만큼 적은 양이기 때문에 제자리 정렬로 보는 것이다.
 * 
 * 이는 선택정렬, 거품 정렬과도 같은 부분이다.
 * 다만, 삽입정렬과는 다르게 일정 간격을 주기로 하여 비교 및 교환이 일어나기 때문에 구조상 안정정렬은 아니다.
 * 
 * 쉘 정렬 방법으로는 
 * 1. 간격을 설정한다.
 * 2. 각 간격별로 분류된 서브 리스트에 대한 삽입 정렬을 한다.
 * 3. 각 서브 리스트의 정렬이 끝나면 간격을 줄인다.
 * 4. 간격이 1이 될 때 까지 2번 과정으로 되돌아가며 반복한다.
 * 
 * 간격이라는 것은 정해진 것이 없다. 하지만 간격이 너무 적으면 건너 뛰는 간격이 적으며 Pass 속도가 느려진다.
 * 반대로 간격이 너무 많으면 오버헤드가 발생한다.
 * 그래서 많은 사람들의 경험을 통하여 평균적으로 좋은 결과를 내는 간격들을 내 놓았다.
 * 이를 갭 시퀸스라고 한다.
 * 
 * 대표적으로 많이 다루는 갭 시퀀스들은 아래와 같다. 이우는 알려진 갭 시퀀스 중에 가장 좋은 퍼포먼스를 보여주었기 때문이다. 
 * A003462(Knuth Sequence)
 * A108870(Tokuda Sequence)
 * A102549(Ciura Sequence)
 * 
 * 쉘 정렬의 장점으로는
 * 1. 멀리 있는 원소들끼리 빠르게 비교 및 교환이 이루어진다.
 * 2. 삽입정렬, 거품정렬에 비해 속도가 빠르다.
 * 
 * 단점으로는 
 * 1. 일반적인 삽입정렬에 비해 구현이 까다롭다.
 * 2. 갭 시퀀스에 영향을 많이 받으며 적절한 시퀀스를 선택해야 한다.
 * 3. 일정 간격을 두고 원소의 교환이 이루어지기 때문에 안정정렬이 아니다.
 * 
 */
	
	// 이 갭은 Cicura 시퀀스의 갭이다.
	// 자바의 Integer은 약 21억을 넘지 못한다.
	private final static int[] gap = 
		{ 1, 4, 10, 23, 57, 132, 301, 701, 1750, 3937, 	
		8858, 19930, 44842, 100894, 227011, 510774,
		1149241, 2585792, 5818032, 13090572, 29453787, 
		66271020, 149109795, 335497038, 754868335, 1698453753};	// 갭을 담고있는 배열	
 
	
	public static void shell_sort(int[] a) {
		shell_sort(a, a.length);
		
	}
 
	// 맨 처음 gap을 참조 할 인덱스를 구하는 메소드
	private static int getGap(int length) {
		int index = 0;
		// 최소한 부분 배열의 원소가 2개씩은 비교 되도록 나눠준다.
		int len = (int)(length / 2.25);	
		while (gap[index] < len) {
			index++;
		}
		return index;
	}
 
	private static void shell_sort(int[] a, int size) {
		int index = getGap(size);	// 첫 gap을 사용할 index
 
		// gap[index] 값부터 gap[0] 까지 반복한다.
		for (int i = index; i >= 0; i--) {
 
			for (int j = 0; j < gap[i]; j++) {	// 각 부분 리스트에 대해 삽입정렬을 한다.
				insertion_sort(a, j, size, gap[i]);
			}
		}
	}
 
	/**
	 * 
	 * @param a		 배열
	 * @param start	 부분 배열의 첫 번째 원소 인덱스 
	 * @param size	 배열의 전체 크기
	 * @param gap	 현재 gap
	 */
	private static void insertion_sort(int[] a, int start, int size, int gap) {
 
		// 부분 배열의 두 번째 원소부터 size까지 반복한다. (gap 값씩 건너띔) 
		for (int i = start + gap; i < size; i += gap) {
 
			int target = a[i];
			int j = i - gap;
 
			// 타겟 원소가 이전의 원소보다 작을 때 까지 반복 
			while (j >= start && target < a[j]) {
				a[j + gap] = a[j];	// 이전 원소를 한 칸씩 뒤로 미룬다.
				j -= gap;
			}
			/*
			 * 위 반복문에서 탈출 하는 경우 앞의 원소가 타겟보다 작다는 의미이므로
			 * 타겟 원소는 j번째 원소 뒤에 와야한다.
			 * 그러므로 타겟은 j + gap 에 위치하게 된다.
			 */
			a[j + gap] = target;
 
		}
	}
	
}
