package level2;

public class 피로도 {
	
	boolean[] checkDungeons;
	int answer = 0;

	public static void main(String[] args) {
		/*
		 * 문제 설명 
		 * XX게임에는 피로도 시스템(0 이상의 정수로 표현합니다)이 있으며, 
		 * 일정 피로도를 사용해서 던전을 탐험할 수 있습니다. 
		 * 이때, 각 던전마다 탐험을 시작하기 위해 필요한 "최소 필요 피로도"와 
		 * 던전 탐험을 마쳤을 때 소모되는 "소모 피로도"가 있습니다.
		 * 
		 * "최소 필요 피로도"는 해당 던전을 탐험하기 위해 가지고 있어야 하는 최소한의 피로도를 나타내며, 
		 * "소모 피로도"는 던전을 탐험한 후 소모되는 피로도를 나타냅니다. 
		 * 예를 들어 "최소 필요 피로도"가 80, "소모 피로도"가 20인 던전을 탐험하기 위해서는 유저의 현재 남은
		 * 피로도는 80 이상 이어야 하며, 던전을 탐험한 후에는 피로도 20이 소모됩니다.
		 * 
		 * 이 게임에는 하루에 한 번씩 탐험할 수 있는 던전이 여러개 있는데, 
		 * 한 유저가 오늘 이 던전들을 최대한 많이 탐험하려 합니다. 
		 *
		 * 유저의 현재 피로도 k와 각 던전별 "최소 필요 피로도", "소모 피로도"가 담긴 
		 * 2차원 배열 dungeons 가 매개변수로 주어질 때, 
		 * 유저가 탐험할수 있는 최대 던전 수를 return 하도록 solution 함수를 완성해주세요.
		 * 
		 * 제한사항
		 * k는 1 이상 5,000 이하인 자연수입니다.
		 * dungeons의 세로(행) 길이(즉, 던전의 개수)는 1 이상 8 이하입니다.
		 * dungeons의 가로(열) 길이는 2 입니다. 
		 * dungeons의 각 행은 각 던전의 ["최소 필요 피로도", "소모 피로도"] 입니다.
		 * "최소 필요 피로도"는 항상 "소모 피로도"보다 크거나 같습니다. 
		 * "최소 필요 피로도"와 "소모 피로도"는 1 이상 1,000 이하인 자연수입니다. 
		 * 서로 다른 던전의 ["최소 필요 피로도", "소모 피로도"]가 서로 같을 수 있습니다.
		 * 
		 */
	}
	
	  public int solution(int k, int[][] dungeons) {
		  /*
		   * 내가 문제 푸는 방법
		   * 
		   * 조건 : 탐험 할 수 있느 최대 던전 수를 구하라.
		   * - 각 던전의 소모 피로도와, 현재 피로도 상태를 확인해야함.
		   * - 던전 입장시 최소 필요 피로도를 고려한다.
		   * - 각 던전 출입 시 현재 피로 k에서 해당 던전의 소모 피로도만큼 감소 시킨다.
		   * 
		   * 여기서 A, B, C, D, E 던전이 있다고 가정하자.
		   * A 던전입장 후, B던전을 가야하는데 피로도 문제로 가지 못하면, 다음 던전인 C에 들어가는
		   * 시도를 해봐야한다. 순차적으로 C를 들어가고 D도 들어갔는데, E에서 막힐 수 도 있다.
		   * 
		   * 또한 A를 나중에 간다고 생각하고 B부터 입장했을 시 , C, D, E 전부 통과할 수도 있다.
		   * 
		   * 이렇게 되는 이유는 소모피로도와 최소피로도 라는 입장 조건이 2가지이기 때문에 던전에 입장하는
		   * 순서에 따라 결과가 바뀔 수 있다.
		   * 
		   * 그렇다면 ? A부터 시도해서, B를 들어가고 이후 C, D, E에 입장 확인하는 방법.
		   * 또는 A부터 시작해서 C, D, E 이후 , B를 마지막으로 입장 확인 하는방법.
		   * 등, 기존의 순차적인 반복문에 변칙을 줘야한다.
		   * 
		   * 그렇다면 반복문 내부에서, 
		   * "현재 피로도보다 최소 필요 피로도가 작으면, 입장하지 않는다." 라는 조건이 필요할 것이다.
		   * 
		   * 그렇다면, 입장 가능 유뮤를 알려주는 코드가 필요할 것이다.
		   * 코드는 알아보기 쉽고, 복잡하지 않게 만들어준다.
		   * => 던전이 여러개니, 던전의 크기만큼 필요하다. 배열을 사용한 변수가 좋겠다.
		   * 
		   * 다시 반복문 내부로 돌아와서, 
		   * "이미 들어간 던전에 대해서 입장하지 않는다." 라는 조건도 추가하자.
		   * 
		   * 위 두 조건에 한하여, 입장이 가능하다면, 해당 던전은 입장한 것으로 처리하고,
		   * 던전에 필요한 피로도는 그만큼 줄어준다.
		   * 
		   * 이제 "한 사이클속의 한 던전에 대하여 코드를 구성한 것이다.=> 반복문 1회가 안끝남."
		   * 
		   * 반복문의 이후 코드가 아무것도 없다면, 던전의 개수만큼만 순서대로 순회하고 끝 날 것이다.
		   * A-B-C-D-E 만 순회하고 끝난다.
		   * 여러 순서로 확인해보기 위해서는 또다른 반복문이 필요할 것이다.
		   * 
		   * 그러면 어떻게 해야할까??
		   * 여기서 부터 감이 오질 않아서 다른 사람들의 코드를 참고해보았다.
		   * 
		   * "재귀함수" 또는 "완전탐색" 을 많이 사용하였다.
		   * 
		   * 적용해보자.
		   *
		   * 반복문으로 돌아와서, 두 가지의 조건이 만족한다면, 다시 그 반복문을 불러오는데
		   * 불러온 반복문(2반복 으로 명명하겠다)에서는 기존의 피로도에서 들어올 때 소모된 피로도를 빼주어야한다.
		   * 
		   * 2반복 에서도 조건을 만족한다면 3반복을 호출하고, 3반복에서도 만족한다면 N 반복까지 한다.
		   * 1반복 에서 2반복, 3반복, N 반복을 불러 낼 때는 그 반복을 불러내 었을 때 확인한 던전들을 확인했다는 표식을
		   * 해주어야한다.
		   * 
		   * 자세한 것은 아래 식에서 설명하겠다.
		   *  
		   * 
		   */
		  	checkDungeons = new boolean[dungeons.length];
	    	
	    	dfs(0,k,dungeons);

	    	return answer;
	    }
	  
	  public void dfs(int enterCnt, int k, int[][] dungeons) {
		  
		  for(int i = 0; i < dungeons.length; i++) {
			  
			  // 현재 피로도가 던전의 최소피로도보다 크고, 그 던전을 입장 안했을 때,
			  if(dungeons[i][0] <= k && !checkDungeons[i] ) {
				  checkDungeons[i] = true; // 이 던전을 입장 했다고 처리하고,
				  
				  // 그만큼 피로도 감소, 던전 확인 카운트
				  dfs(enterCnt+1, k-dungeons[i][1], dungeons); 
				  // 던전 확인 카운트를 ++ 연산자를 사용하게되면
				  // 다시 메서드 이후 코드에서 -- 연산자를 취해줘야함.
				  // => 현재 반복문 내의 변수 자체의 값이 바뀌는 것임.
				  
				  // 위의 dfs 과정이 다 끝나면? 다음 순회에, 영향을 미치지 않기 위헤
				  // 현재 반복문의 다음 순회에 영향을 미치지 않기 위해 현재 던전을 확인 안한 것으로 처리.
				  checkDungeons[i] = false;
			  }
		  }
		  answer = Math.max(answer, enterCnt);
		  
	  }
}
	  
/*
 * 맨 처음 풀었을때는 그저 조건문을 많이 주어 정답에 가까워는 졌지만.. 통과를 하지 못하였고
 * 식이 점점 복잡해졌었다.
 * 
 * 완전 탐색을 위한 재귀 호출을 공부하였고, 다시 풀어보니
 * 식을 만들 때는 많은 시간과 노력이 필요하였지만, 코드도 간단하고
 * 
 */
	
