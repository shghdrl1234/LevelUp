package level2;

public class 삼각달팽이 {

	public static void main(String[] args) {
		/*
		 * 문제 설명 정수 n이 매개변수로 주어집니다. 
		 * 다음 그림과 같이 밑변의 길이와 높이가 n인 삼각형에서 맨 위 꼭짓점부터 반시계 방향으로 
		 * 달팽이 채우기를 진행한 후, 첫 행부터 마지막 행까지 모두 순서대로 합친 새로운 배열을 
		 * return 하도록 solution 함수를 완성해주세요.
		 * 
		 * 제한사항 
		 * n은 1 이상 1,000 이하입니다.
		 */

	}
	
    public int[] solution(int n) {

    	/*
    	 * 내가 푸는 방법
    	 * 
    	 * 1. 1~n까지 시계 반대방향으로 말려 들어가, 값을 채우면서 삼각형을 만든다.
    	 * => 방향성이 있다. (좌하단 => 가로 => 좌상단)
    	 * => n을 향해서 증가함.
    	 * 
    	 * 2. 배열의 인덱스를 좌표로 나타낸다고 가정해보자
    	 * => 좌하단으로 가는 방향: x좌표(1차 배열 인덱스) 증가
    	 * => 가로로 가는 방향 : y좌표(2차 배열 인덱스) 증가
    	 * => 좌상단으로 가는 방향 : x좌표, y 좌표 감소
    	 * 
    	 * (0,0)(0,1)(0,2). . (0,n)
    	 * (1,0)(1,1)(1,2). . (1,n)
    	 * (2,0)(2,1)(2,2). . (2,n)
    	 * .
    	 * .
    	 * (n,0)(n,1)(n,2). . (n,n)
    	 * 
    	 */
    	int[][] arr = new int[n][n];
    	int[] answer = new int[n];
    	
    	int x = -1; // 1차 배열의 인덱스 번호를 지정하기 위함.
    	int y = 0; // 2차 배열의 인덱스 번호를 지정하기 위함.
    	int num = 1; // 배열에 저장하기 위한 변수 (1~n)이 들어갈 예정
    	
    	for(int i = 0; i < n; i++) {
    		// i의 개수는 총 반복될 개수(방향 전환의 개수)
    		for(int j = i; j < n; j++) {
    			// j 는 방향 전환 후, 숫자를 입력하는 횟수
    			if(i%3 == 0) {
    				// 1부터 n번째 수가 입력되는 조건문.
    				// 즉, 1이라는 숫자부터 다른 방향으로 바뀌기 전까지를 나타냄.
    				// 1부터 ~ n 까지, 또 방향이 2회 바뀌고 난 이후의 값들은 
    				// 전부 좌하단으로 방향을 가짐.
    				x++;
    			} else if(i%3 == 1) {
    				y++;
    				
    			} else {
    				x--;
    				y--;
    			}
    			arr[x-1][y] = num;
    			num++;
    		}
    	}
    	
    	int z = 0;
    	for(int[] i : arr) {
    		
    		for(int j : i) {
    			if(j == 0) {
    				break;
    			}
    			answer[z] += j;
    		z++;
    		}
    		
    	}
    	
        return answer;
    }
}

/*
 * 이거는 될 듯 말듯 하다가 너무 답답해서 문제 풀이를 참고하였다.
 * 
 * 참고하면 쉬워보이는건 항상 그렇다.
 * 
 * 일단은 내가 생각했던 문제 접근 방법에 차이가 있었던 것은
 * 
 * 위치의 "좌표화" 였다.
 * 
 * 규칙과, 위치마다의 연관성을 찾았지만, 좌표화를 하지 못하여
 * 
 * 많은 시행착오를 겪게되었다.
 * 
 * 조금은 단순하게 생각할 필요도 있던 문제였다.
 * 
 * 
 */

