package level1;

import java.util.Arrays;

public class 예산 {

	public static void main(String[] args) {
		/*
		 * 
		 * 문제 설명 
		 * S사에서는 각 부서에 필요한 물품을 지원해 주기 위해 
		 * 부서별로 물품을 구매하는데 필요한 금액을 조사했습니다. 
		 * 그러나, 전체 예산이 정해져 있기 때문에 모든 부서의 물품을 구매해 줄 수는 없습니다. 
		 * 그래서 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.
		 * 
		 * 물품을 구매해 줄 때는 각 부서가 신청한 금액만큼을 모두 지원해 줘야 합니다. 
		 * 예를 들어 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 
		 * 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.
		 * 
		 * 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 
		 * 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.
		 * 
		 * 제한사항 
		 * d는 부서별로 신청한 금액이 들어있는 배열이며, 
		 * 길이(전체 부서의 개수)는 1 이상 100 이하입니다. 
		 * 
		 * d의 각 원소는 부서별로 신청한 금액을 나타내며, 
		 * 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다. 
		 * 
		 * budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.
		 * 
		 */
		solution(new int[] {1,2,3,4,5}, 100);
		
	}
	
    public static int solution(int[] d, int budget) {
    	
    	/*
    	 * 내가 문제 푸는 방법
    	 *  1. budget - for (int i : d)
    	 *  2. "최대"로 많은 부서에게 지원해줘야함 => 신청 예산이 적은 부서에게 먼저 할당.
    	 *  3. 한 번 순회하여 신청 예산이 "최소"인 부서를 찾았다. => 다음 으로 적게 신청한 사람을 찾아야함.
    	 *  
    	 *  4. sort메서드 사용해서 오름차순 정렬
    	 *  5. 이후 budget에 순차적으로 적용
    	 *  
    	 */
    	

    	Arrays.sort(d);
    	
    	int answer = 0;
    	while(budget > 0 && answer <= d.length-1 ) {
    		
    		budget -= d[answer];
    		
    		if(budget < 0) {
    			break;
    		}

    		answer++;
    	}
    	
    	System.out.println(answer);
    	
    		
    	
        return answer;
    }
	

}


/*
 * 현재까지 유일하게 다른 사람의 코드를 가져오지 않은 문제.
 * 
 * 이유는 내가 아직 익히지 못한 메서드, 기술을 사용하지 않아도 될 만큼의 문제이자,
 * 그런 문제들 중에 사용된 코드들 중에 나의 코드가 가장 간결하였다.
 * 
 * 비유하지면 나의 수준은 뱀의 머리에 위치하였다. 라고 볼 수 있겠다.
 * 
 * 하지만 그 뱀이 뱀 중에서 서열이 가장 낮은 친구겠지..
 * 
 */

