package level1;

import java.util.Stack;

public class 햄버거만들기 {

	public static void main(String[] args) {
		/*
		 * 문제 설명 
		 * 햄버거 가게에서 일을 하는 상수는 햄버거를 포장하는 일을 합니다. 
		 * 함께 일을 하는 다른 직원들이 햄버거에 들어갈 재료를 조리해주면 
		 * 조리된 순서대로 상수의 앞에 아래서부터 위로 쌓이게 되고, 
		 * 상수는 순서에 맞게 쌓여서 완성된 햄버거를 따로 옮겨 포장을 하게 됩니다.
		 * 
		 * 상수가 일하는 가게는 정해진 순서(아래서부터, 빵 - 야채 - 고기 - 빵)로 쌓인 햄버거만 포장을 합니다. 
		 * 상수는 손이 굉장히 빠르기 때문에 상수가 포장하는 동안 속 재료가 추가적으로 들어오는 일은 없으며, 
		 * 재료의 높이는 무시하여 재료가 높이 쌓여서 일이 힘들어지는 경우는 없습니다.
		 * 
		 * 예를 들어, 
		 * 상수의 앞에 쌓이는 재료의 순서가 [야채, 빵, 빵, 야채, 고기, 빵, 야채, 고기, 빵]일 때, 
		 * 상수는 여섯 번째 재료가 쌓였을 때, 세 번째 재료부터 여섯 번째 재료를 이용하여 햄버거를 포장하고, 
		 * 
		 * 아홉 번째 재료가 쌓였을 때, 두 번째 재료와 일곱 번째 재료부터 
		 * 아홉 번째 재료를 이용하여 햄버거를 포장합니다. 즉, 2개의 햄버거를 포장하게 됩니다.
		 * 
		 * 상수에게 전해지는 재료의 정보를 나타내는 정수 배열 ingredient가 주어졌을 때, 
		 * 상수가 포장하는 햄버거의 개수를 return 하도록 solution 함수를 완성하시오.
		 * 
		 * 제한사항
		 * 1 ≤ ingredient의 길이 ≤ 1,000,000 ingredient의 원소는 1, 2, 3 중 하나의 값이며, 
		 * 순서대로 빵, 야채, 고기를 의미합니다.
		 * 
		 */
		System.out.println(solution(new int[] {1,2,1,2,3,1,3,1,2,3}));

	}
	
    public static int solution(int[] ingredient) {
    	
    	/*
    	 * 내가 문제 푸는 방법
    	 * 
    	 * 1. 재료는 0번부터 하나씩 들어온다. 여기서 빵 - 야채 - 고기 - 빵 순서가 연속되면 햄버거가 만들어진다.
    	 * => stack 구조로 ingredient의 요소를 넣고, 빵-야채-고기-빵이 완성되면, pop을 4번 진행한다.
    	 * => pop이 진행되면 cnt ++1;
		*
    	 * 3. get()메서드로 요소를 확인한다. 1(첫번째)~4(번째) 순서가 빵-고기-야채-빵이 되어야함.
    	 * => 문제에서는 빵-야채-고기-빵이다. Stack 구조는 FILO이기 때문에, 순서가 뒤바뀐다. 
    	 * 그러니 야채와 고기의 순서가 반대로 되어야함.
    	 * 
    	 * 
    	 * 
    	 */	
    	Stack<Integer> s = new Stack<Integer>();
  
        int answer = 0;
       
        // 각 재료를 하나씩 stack에 쌓으면서 순회한다..
        for(int i : ingredient) {
        	s.push(i);
        	
        	// stack의 가장 위에 위치한 요소가 빵(1) 일 경우 
        	if(s.size() >= 4 && s.get(s.size()-1) == 1 && s.get(s.size()-2) == 3 && s.get(s.size()-3) == 2 && s.get(s.size()-4) == 1 ) {
        		answer ++;
        		s.pop();
        		s.pop();
        		s.pop();
        		s.pop();
        	}
        }
    	
        return answer;
    }
	
}

class 햄버거만들기_다른사람 {
    public int solution(int[] ingredient) {
        int[] stack = new int[ingredient.length];
        int sp = 0;
        int answer = 0;
        for (int i : ingredient) {
            stack[sp++] = i;
            if (sp >= 4 && stack[sp - 1] == 1
                && stack[sp - 2] == 3
                && stack[sp - 3] == 2
                && stack[sp - 4] == 1) {
                sp -= 4;
                answer++;
            }
        }
        return answer;
    }
    /*
     * 배열을 리스트로 변환안하고 푼 사람의 소스 코드
     * 의문점이 드는 것은 기존의 배열의 경우, pop() 메서드를 대신하는 것이 없어
     * 삭제를 해주고, 그 만큼 자리를 당겨야하는데 그런 코드가 안보인다.
     * 아직은 이해가 가지 않는 코드다.
     * => stack[sp++] = i; 이 코드로 기존의 요소를 덮어 씌워서 가능하군..
     */
}

/*
 * 처음엔 반복문만 주구장창 쓰면 될 줄 알고 자료구조를 고려하지 않았다.
 * 뭔가 문제를 풀어가면서 답답한것들이 많이 느껴졌고 코드들이 힘겹게 돌아가는게 마음속에 걸려
 * 자료 구조를 조금 공부하고 왔더니 쉽게 풀린 것 같다.
 */ 
