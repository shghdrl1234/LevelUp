package helper;

public class 소수찾기 {

	/*
	 * 소수는 1보다 큰 자연수 중 1과 자기 자신만을 약수로 갖는 자연수를 의미한다.
	 * 
	 * 즉, 소수의 약수는 2개이다.
	 * 
	 * 프로그래밍에서 소수가 중요한 이유는 암호 때문이다.
	 * 
	 * 우리는 일상생활 속에서도 많이 쓰이는 암호 또한 소수를 이용하고 있다.
	 * 대표적으로 RSA 암호화 방식이 있다.
	 * 
	 * 위 암호화 방식의 가장 근복적인 접근 방식은 이렇다.
	 * 
	 * "임의의 수들의 곱은 구하기가 쉽지만 역으로 소인수 분해하는 것은 어렵다."
	 * 
	 * 즉, p * q = N을 만들기는 쉽지만, N을 역으로 소인수 분해하여 p * q를 만족하는 수를 찾기 어렵다.
	 * 
	 * 수가 커질 수록 소인수 분해의 과정을 많이 거쳐야하고, 어떤 소수가 쓰이는지 알아내기 힘들다.
	 * 
	 * 현재 공개된 RSA-129의 공개키는 129자리이다.
	 * 114381625757888867669235779976146612010218296721242362562561842935706935245733897830597123563958705058989075147599290026879543541
	 * 
	 * 그리고 소수는
	 * 3490529510847650949147849619903898133417764638493387843990820577 
	 * 32769132993266709549961988190834461413177642967992942539798288533
	 * 
	 * 이 두 수이다. 
	 * 
	 * 부가적인 설명은 여기까지 하고, 소수를 판별하는 알고리즘과,
	 * N 이하의 소수를 모두 구하는 알고리즘을 알아보자.
	 */
	

	public class prime1 {
		
		
		public static void main(String[] args){
			
			int num1 = 30;
			
			// 2 이상 N 미만의 수 중에 나누어 떨어지는 수가 존재한다면 소수가 아님을 이용한 소수 판별법이다.
			// 또한, 이 알고리즘의 시간복잡도는 당연히 N 이하의 수까지 모든 수를 검사하므로 O(N)이다.
			is_prime(num1);
			
			
			
			int num2 = 100;
			
			// 특정 자연수 까지 소수가 몇 개 인지 알 수 있는 방법
			// 기존 메서드에 N 까지의 순회를 실시하기 떄문에, 시간 복잡도는 O(N^2)이다.
			for(int i = 0; i <= num2; i++) {
				is_prime(i);
			}
			
		}
		
		// 가장 기본적인 방법이다. 임의의 수 N이 1과 N을 제외한 다른 수를 약수로 갖고 있다면
		// 그 수는 소수가 아니고, 만약 다른 약수가 없다면 그 수는 소수일 것이다.
		public static void is_prime(int num) {
			// 0과 1은 소수가 아니다.
			if(num < 2) {
				System.out.print("소수가 아닙니다");
				return;
			}
			// 2는 소수다.
			if(num == 2) {
				System.out.print("소수입니다");
				return;
			}
			//반복문에서 약수를 갖고 있지 않는경우 소수다.
			for(int i = 2; i < num; i++) {
				// 소수가 아닐경우
				if(num % i == 0) {
					System.out.print("소수가 아닙니다");
					return;
				}
			}
			System.out.print("소수입니다 : " + num);
			return;
		}
			
	}
	
	/*
	 * 두 번째 방법은 N의 제곱근 이하의 자연수들로 모두 나눠본다.
	 * 
	 * 첫 번째 방법에서 약간 업그레이드 된 알고리즘이다.
	 * 
	 * 소수를 판별한다는 것은 결국 1과 자기 자신을 제외한 다른 자연수를 약수로 갖고 있으면 안된다는 의미다.
	 * 
	 * 임의의 자연수 N (N > 0)이 있다고 가정하자.
	 * p * q = N을 만족할 때 우리는 아래와 같은 부등식을 완성할 수 있다.
	 * 
	 * (1 <= p, q <= N)
	 * 그리고 p와 q중 하나는 제곱근 N보다 작거나 같다.
	 * 
	 * p가 증가한다면, q가 감소하게 될 것이다.
	 * 
	 * 결과적으로는 p와 q 중 하나는 반드지 N의 제곱근보다 작거나 같을 것이다.
	 * 
	 * 즉, N의 제곱근 이하의 자연수 중에 나누어 떨어지는 수가 있다면, 이는 1과 N을 제외한 다른 자연수가
	 * N의 약수라는 의미이므로 소수가 아니게 되는 것이다.
	 * 
	 * 2이상 N제곱근 이하의 수 중에 나누어 떨어지는 수가 존재한다면 소수가 아님을 이용한 소수 판별법이다.
	 * 
	 * 시간복잡도는 제곱근 N 이하의 수까지 모두 검사하므로 O(N의 제곱근) 이다.
	 * 
	 * 1번 방법과 같은 식으로 전체 수에대해 반복문을 돌려 N 번째 자연수 까지 소수를 얻을 수 있다.
	 * 그 때의 시간복잡도는 O(N * N의 제곱근) 이다.
	 */
	public class prime2 {
		
		public static void is_prime(int number) {
			 
			// 0 과 1 은 소수가 아니다
			if(number < 2) {
				System.out.print("소수가 아닙니다");
				return;
			}
			
			// 2 는 소수다
			if(number == 2) {
				System.out.print("소수입니다");
				return;
			}
			
			// 제곱근 함수 : Math.sqrt()
			for(int i = 2; i <= Math.sqrt(number); i++) {
	        
				// 소수가 아닐경우
				if(number % i == 0) {
					System.out.print("소수가 아닙니다");
					return;
				}
			}
			// 위 반복문에서 약수를 갖고 있지 않는경우 소수다.
			System.out.print("소수입니다");
			return;
		}
	}
	
	/*
	 * 세 번째 방법은 에라토스테네스의 채이다.
	 * 
	 * 소수를 구하는 대표적인 방법중 하나이며, K=2부터 N의 제곱근 이하까지 반복하여 자연수들 중 K를 제외한
	 * K의 배수들을 제외시킨다.
	 * k = 2 이면 2 를 제외한 2의 배수를 모두 지워주고,
	 * k = 3 이면 3 을 제외한 3의 배수를 모두 지워주고,
 	 * (4는 이미 k = 2 에서 제외되어 넘어간다.)
	 * k = 5 이면 5 를 제외한 5의 배수를 모두 지워주고..
	 * 이렇게 하여 k = 제곱근 N 까지 반복하는 방법이다.
	 */
	public class Prime3 {
		 
		public static boolean[] prime;	// 소수를 체크할 배열
		public static void main(String[] args) {
			int num1 = 30;
			make_prime(num1);
	 
			for(int i = 0; i < prime.length; i++) {
				if(prime[i] == false) {	// 소수(false)일 경우 출력
					System.out.println(i);
				}
			}
		}
		// N 이하 소수 생성 메소드 
		public static void make_prime(int N) {
			
			prime = new boolean[N + 1];	// 0 ~ N
	 
			/*
			소수가 아닌 index = true
			소수인 index = false
			*/
			
			// 2 미만의 N 을 입력받으면 소수는 판별할 필요 없으므로 바로 return
			if(N < 2) {
				return;
			}
	        
			prime[0] = prime[1] = true;
	        
			// 제곱근 함수 : Math.sqrt()
			for(int i = 2; i <= Math.sqrt(N); i++) {
	        
				// 이미 체크된 배열이면 다음 반복문으로 skip
				if(prime[i] == true) {
					continue;
				}
	        
				// i 의 배수들을 걸러주기 위한 반복문
				for(int j = i * i; j < prime.length; j = j+i) {
					prime[j] = true;
				}
			}
	 
		}
	 
	}

}


